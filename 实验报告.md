# Lab3 中断机制实验答辩文档

> **学号**: 2310675
> **实验环境**: RISC-V 64 (QEMU + OpenSBI)
> **完成情况**: 练习1 + Challenge 1/2/3 全部完成

---

## 目录
1. [实验概述与完成情况](#1-实验概述与完成情况)
2. [RISC-V中断机制原理](#2-risc-v中断机制原理)
3. [练习1：时钟中断处理](#3-练习1时钟中断处理)
4. [Challenge1：中断流程详解](#4-challenge1中断流程详解)
5. [Challenge2：上下文切换机制](#5-challenge2上下文切换机制)
6. [Challenge3：异常处理完善](#6-challenge3异常处理完善)
7. [关键代码讲解](#7-关键代码讲解)
8. [知识点总结](#8-知识点总结)

---

## 1. 实验概述与完成情况

### 1.1 实验目标
本实验旨在理解和实现RISC-V架构下的中断异常处理机制，包括：
- 中断向量表的设置（stvec）
- 上下文保存与恢复（trapframe）
- 时钟中断的处理
- 各类异常的捕获与处理

### 1.2 完成情况

| 任务 | 完成状态 | 核心文件 |
|------|---------|---------|
| 练习1: 时钟中断处理 | ✅ 完成 | [trap.c:129-150](kern/trap/trap.c#L129-L150) |
| Challenge1: 中断流程分析 | ✅ 完成 | 理论分析 |
| Challenge2: 上下文切换理解 | ✅ 完成 | [trapentry.S](kern/trap/trapentry.S) |
| Challenge3: 异常处理完善 | ✅ 完成 | [trap.c:181-204](kern/trap/trap.c#L181-L204) |

### 1.3 实验验证结果
```bash
$ make qemu
# 输出:
Illegal instruction caught at 0x80200058
Exception type: Illegal instruction
ebreak caught at 0x8020005c
Exception type: breakpoint
100 ticks
100 ticks
...
100 ticks  # 第10次打印后系统调用sbi_shutdown()关机
```

---

## 2. RISC-V中断机制原理

### 2.1 中断分类

根据RISC-V特权架构规范，trap分为三大类：

#### （1）异常（Exception）
- **定义**: 指令执行过程中发生的同步错误
- **典型示例**: 非法指令、地址未对齐、缺页异常
- **特点**: 可以精确定位到触发异常的指令（sepc指向该指令）

#### （2）陷入（Trap）
- **定义**: 程序主动触发的特权级切换
- **典型示例**:
  - `ecall` - 系统调用（U→S或S→M）
  - `ebreak` - 断点调试
- **特点**: 可预期、可恢复

#### （3）外部中断（Interrupt）
- **定义**: 异步的硬件信号
- **典型示例**: 时钟中断（IRQ_S_TIMER）、外设中断
- **特点**: 发生时刻不确定，需要CPU定期检查中断引脚

### 2.2 特权级与中断委托

#### RISC-V三个特权级
```
M模式（Machine）      - 最高权限，固件(OpenSBI)运行
  ↓ mret/委托
S模式（Supervisor）   - 操作系统内核运行
  ↓ sret/ecall
U模式（User）         - 用户程序运行
```

#### 中断委托机制
OpenSBI通过设置 `mideleg` 和 `medeleg` 寄存器，将大部分中断/异常委托给S模式处理：
```c
// 委托后的路由规则:
U模式触发 → 直接进入S模式 (不经过M模式)
S模式触发 → S自陷 (内核处理自己的中断)
M模式中断 → M模式处理 (不委托)
```

### 2.3 关键CSR寄存器

| 寄存器 | 作用 | 硬件行为 |
|--------|------|----------|
| **stvec** | 中断向量表基址 | trap发生时跳转到stvec指向的地址 |
| **sepc** | 异常指令地址 | 自动保存触发trap的指令PC |
| **scause** | 中断/异常原因 | 最高位=1表示中断，其余位编码具体类型 |
| **stval** | 附加信息 | 缺页时存地址，非法指令时存指令码 |
| **sstatus** | 状态寄存器 | SIE(中断使能), SPP(先前特权级), SPIE |
| **sscratch** | 临时交换 | 用于区分U/S态陷入 |

#### sstatus关键位详解
```
SIE (bit 1):  S模式中断使能
  - 0: 禁用中断 (中断处理期间)
  - 1: 允许中断

SPIE (bit 5): 陷入前的SIE值
  - trap发生时: SPIE ← SIE, SIE ← 0
  - sret返回时: SIE ← SPIE, SPIE ← 1

SPP (bit 8):  陷入前的特权级
  - 0: 来自U模式
  - 1: 来自S模式
  - sret时根据SPP恢复特权级
```

### 2.4 中断处理流程（硬件自动完成部分）

当中断/异常发生时，硬件**自动**执行以下操作：
```
1. sepc ← 当前PC（异常指令或被打断指令的地址）
2. scause ← 中断/异常类型编码
3. stval ← 附加信息（地址/指令）
4. sstatus.SPIE ← sstatus.SIE
5. sstatus.SIE ← 0               # 禁用中断
6. sstatus.SPP ← 当前特权级
7. 切换到S模式
8. PC ← stvec                    # 跳转到中断入口
```

---

## 3. 练习1：时钟中断处理

### 3.1 实验要求
- 每100次时钟中断输出一次 `"100 ticks"`
- 输出10行后调用 `sbi_shutdown()` 关机
- 每次中断后需设置下一次时钟事件

### 3.2 实现原理

#### （1）时钟硬件机制
RISC-V提供的时钟支持：
- **rdtime指令**: 读取CSR `time`，返回自启动以来的时间计数
- **OpenSBI接口**: `sbi_set_timer(uint64_t stime_value)` 在time到达指定值时触发中断

在QEMU上，time寄存器以10MHz频率递增：
```
1秒 = 10,000,000 个time单位
设置 timebase = 100,000 → 约10ms触发一次中断
100次中断 = 1秒
```

#### （2）时钟初始化流程
```c
// kern/driver/clock.c
void clock_init(void) {
    set_csr(sie, MIP_STIP);      // ①使能S模式时钟中断
    clock_set_next_event();      // ②设置第一次时钟事件
    ticks = 0;                   // ③初始化计数器
}

void clock_set_next_event(void) {
    sbi_set_timer(get_cycles() + timebase);  // 当前时间 + 100000
}
```

### 3.3 核心代码实现

```c
// kern/trap/trap.c (第129-150行)
case IRQ_S_TIMER:
    /* LAB3 EXERCISE1   2310675 */
    clock_set_next_event();     // ①立即设置下次中断，防止中断丢失
    ticks++;                    // ②全局计数器自增

    if (ticks % TICK_NUM == 0) {
        print_ticks();          // ③每100次输出提示
        tick_prints++;          // ④记录打印次数

        if (tick_prints == 10) {
            sbi_shutdown();     // ⑤第10次打印后关机
        }
    }
    break;
```

### 3.4 执行流程图
```
[时间线]
   ↓ timebase时间过去
硬件time寄存器到达设定值
   ↓
触发IRQ_S_TIMER中断
   ↓
硬件跳转到stvec(__alltraps)
   ↓
SAVE_ALL保存上下文
   ↓
trap() → interrupt_handler() → IRQ_S_TIMER分支
   ↓
执行我们的代码:
  - clock_set_next_event()  # 预约下次10ms后中断
  - ticks++
  - 判断是否打印/关机
   ↓
RESTORE_ALL恢复上下文
   ↓
sret返回原执行流
   ↓
继续运行，等待下次时钟中断...
```

### 3.5 关键问题

**Q: 为什么要在处理中断时立即调用 `clock_set_next_event()`？**

A: OpenSBI的 `sbi_set_timer()` 只能设置**一次性**事件。如果不在每次中断处理时重新设置，就不会有下一次时钟中断。这是一种"单次触发+软件重设"的设计，避免硬件定时器状态机复杂化。

**Q: 如何保证时钟周期的准确性？**

A: 代码中设置的是**绝对时间点**：
```c
sbi_set_timer(get_cycles() + timebase);
// 当前时刻 + 固定间隔 = 下次触发的绝对时间
```
即使中断处理耗时，下次触发仍以精确的time值为准，不会累积误差。

### 3.6 实际运行结果验证

运行 `make qemu` 后的完整输出：

```
OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
DTB Init
HartID: 0
DTB Address: 0x82200000
Physical Memory from DTB:
  Base: 0x0000000080000000
  Size: 0x0000000008000000 (128 MB)
  End:  0x0000000087ffffff
DTB init completed
(THU.CST) os is loading ...
Special kernel symbols:
  entry  0xffffffffc0200054 (virtual)
  etext  0xffffffffc0201fc8 (virtual)
  edata  0xffffffffc0207028 (virtual)
  end    0xffffffffc02074a0 (virtual)
Kernel executable memory footprint: 30KB
memory management: default_pmm_manager
physcial memory map:
  memory: 0x0000000008000000, [0x0000000080000000, 0x0000000087ffffff].
check_alloc_page() succeeded!
satp virtual address: 0xffffffffc0206000
satp physical address: 0x0x80206000
++ setup timer interrupts
sbi_emulate_csr_read: hartid0: invalid csr_num=0x302
Illegal instruction caught at 0xffffffffc020009c
Exception type: Illegal instruction
ebreak caught at 0xffffffffc02000a0
Exception type: breakpoint
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
100 ticks
```

#### 输出分析

**① OpenSBI启动阶段**（M模式固件）：
```
OpenSBI v0.4                           ← M模式固件启动
Platform Name: QEMU Virt Machine       ← 运行在QEMU虚拟机上
Platform HART Features: RV64ACDFIMSU   ← 支持的RISC-V扩展
  - RV64: 64位基础指令集
  - A: 原子指令扩展
  - C: 压缩指令扩展 (16位指令)
  - D/F: 双精度/单精度浮点
  - I: 基础整数指令
  - M: 乘除法扩展
  - S: Supervisor模式支持
  - U: User模式支持
Current Hart: 0                        ← 当前硬件线程ID
Firmware Base: 0x80000000              ← OpenSBI固件起始地址
Runtime SBI Version: 0.1               ← SBI接口版本
```

**② 物理内存保护配置**（PMP寄存器）：
```
PMP0: 0x80000000-0x8001ffff (A)        ← 保护OpenSBI固件区域
PMP1: 0x00000000-0xffffffff (A,R,W,X)  ← 其余内存可读写执行
```

**③ 设备树初始化**（DTB）：
```
DTB Init
HartID: 0
DTB Address: 0x82200000               ← 设备树存放地址
Physical Memory from DTB:
  Base: 0x80000000                    ← 物理内存起始
  Size: 0x08000000 (128 MB)           ← QEMU分配的内存大小
  End:  0x87ffffff                    ← 物理内存结束
DTB init completed                    ← Lab2新增的DTB解析功能
```

**④ 内核初始化**：
```
(THU.CST) os is loading ...           ← kern_init()开始执行
Special kernel symbols:                ← 内核链接脚本生成的符号
  entry  0xffffffffc0200054           ← 内核入口（虚拟地址）
  etext  0xffffffffc0201fc8           ← 代码段结束
  edata  0xffffffffc0207028           ← 数据段结束
  end    0xffffffffc02074a0           ← 内核结束（BSS段之后）
Kernel executable memory: 30KB         ← 内核总大小
memory management: default_pmm_manager ← 使用默认物理内存管理器
check_alloc_page() succeeded!          ← 物理页分配测试通过
satp virtual address: 0xffffffffc0206000  ← 页表虚拟地址
satp physical address: 0x80206000      ← 页表物理地址
```

**⑤ 中断机制初始化**：
```
++ setup timer interrupts              ← clock_init()执行
                                       ← set_csr(sie, MIP_STIP)使能时钟中断
                                       ← sbi_set_timer()设置第一次中断
                                       ← intr_enable()设置sstatus.SIE=1
```

**⑥ 异常处理验证**（Challenge3）：
```
sbi_emulate_csr_read: hartid0: invalid csr_num=0x302
  ↑ OpenSBI警告：尝试读取M模式CSR (medeleg=0x302)
  ↑ 这是mret指令触发的，可以忽略

Illegal instruction caught at 0xffffffffc020009c  ← ✅ 捕获mret
Exception type: Illegal instruction                ← ✅ 正确识别
ebreak caught at 0xffffffffc02000a0                ← ✅ 捕获ebreak
Exception type: breakpoint                         ← ✅ 正确识别
```

**⑦ 时钟中断循环**（练习1）：
```
100 ticks    ← T0: 第1秒
100 ticks    ← T1: 第2秒
100 ticks    ← T2: 第3秒
...
100 ticks    ← T9: 第10秒，调用sbi_shutdown()
```

#### 执行时间轴

| 时刻 | 事件 | 特权级 | 关键操作 |
|------|------|--------|----------|
| T0 | OpenSBI启动 | M | 初始化硬件、设置委托 |
| T1 | 进入kern_init() | S | 内核开始执行 |
| T2 | idt_init() | S | 设置stvec=__alltraps |
| T3 | clock_init() | S | 设置第一次时钟事件 |
| T4 | intr_enable() | S | sstatus.SIE=1 |
| **T5** | **执行mret** | **S→S** | **触发非法指令异常** |
| **T6** | **执行ebreak** | **S→S** | **触发断点异常** |
| T7 | 进入while(1) | S | CPU空转等待中断 |
| T8 | 第1次时钟中断 | S→S | 输出"100 ticks" |
| ... | 每秒一次 | S→S | ticks计数 |
| T18 | 第10次时钟中断 | S→M | sbi_shutdown() |

---

## 4. Challenge1：中断流程详解

### 4.1 完整中断处理流程（从异常产生到返回）

```
┌──────────────────────────────────────────────────┐
│  用户程序执行 (U模式)                              │
│  ...                                              │
│  lw a0, 0(zero)  ← 访问非法地址触发异常            │
└──────────────────────────────────────────────────┘
                    ↓ [硬件自动]
┌──────────────────────────────────────────────────┐
│  硬件保存现场:                                     │
│  • sepc ← 当前PC                                  │
│  • scause ← CAUSE_FAULT_LOAD                     │
│  • stval ← 0x0 (错误地址)                         │
│  • sstatus: SPP←0, SPIE←SIE, SIE←0              │
│  • 特权级 → S模式                                  │
│  • PC ← stvec (跳转到__alltraps)                  │
└──────────────────────────────────────────────────┘
                    ↓
┌──────────────────────────────────────────────────┐
│  kern/trap/trapentry.S: __alltraps               │
│  ┌────────────────────────────────┐              │
│  │  SAVE_ALL 宏展开:               │              │
│  │  1. csrw sscratch, sp          │ 保存旧sp     │
│  │  2. addi sp, sp, -36*REGBYTES  │ 分配trapframe│
│  │  3. STORE x0~x31               │ 保存32个寄存器│
│  │  4. csrrw s0, sscratch, x0     │ 取回旧sp     │
│  │  5. STORE s0 → 2*REGBYTES(sp)  │ 存入结构体   │
│  │  6. 读取并保存sstatus/sepc/    │              │
│  │     stval/scause → 栈          │              │
│  └────────────────────────────────┘              │
└──────────────────────────────────────────────────┘
                    ↓
┌──────────────────────────────────────────────────┐
│  move a0, sp  ← 将trapframe地址传给C函数           │
│  jal trap                                         │
└──────────────────────────────────────────────────┘
                    ↓
┌──────────────────────────────────────────────────┐
│  kern/trap/trap.c: trap(struct trapframe *tf)    │
│  ↓                                                │
│  trap_dispatch(tf)                               │
│  ↓ 根据scause最高位判断                            │
│  exception_handler(tf)  ← 本例进入这里             │
│  ↓ switch(tf->cause)                             │
│  CAUSE_FAULT_LOAD分支:                            │
│    打印错误信息                                     │
│    可能终止进程或触发缺页处理                        │
└──────────────────────────────────────────────────┘
                    ↓ [C函数返回]
┌──────────────────────────────────────────────────┐
│  __trapret:                                       │
│  ┌────────────────────────────────┐              │
│  │  RESTORE_ALL 宏展开:            │              │
│  │  1. LOAD sstatus/sepc ← 栈     │              │
│  │  2. csrw sstatus/sepc          │ 恢复CSR      │
│  │  3. LOAD x1~x31 ← 栈           │ 恢复寄存器   │
│  │  4. LOAD sp ← 栈               │ 最后恢复sp   │
│  └────────────────────────────────┘              │
│  sret  ← 特权指令                                 │
└──────────────────────────────────────────────────┘
                    ↓ [硬件自动]
┌──────────────────────────────────────────────────┐
│  sret指令行为:                                     │
│  • PC ← sepc                                      │
│  • 特权级 ← sstatus.SPP (0→U模式)                 │
│  • sstatus.SIE ← sstatus.SPIE                    │
│  • sstatus.SPIE ← 1                              │
└──────────────────────────────────────────────────┘
                    ↓
┌──────────────────────────────────────────────────┐
│  返回用户程序 (如果异常可恢复)                      │
│  或跳转到信号处理/进程终止逻辑                      │
└──────────────────────────────────────────────────┘
```

### 4.2 关键问题解答

#### Q1: `move a0, sp` 的目的是什么？

**答案**：
```assembly
# trapentry.S
__alltraps:
    SAVE_ALL           # 此时sp指向刚构造好的trapframe结构体
    move a0, sp        # 把trapframe地址传给C函数
    jal trap           # 调用 trap(struct trapframe *tf)
```

根据RISC-V调用约定（ABI）：
- **a0寄存器** 用于传递**第一个参数**
- C函数 `void trap(struct trapframe *tf)` 需要读取保存的寄存器值

通过 `move a0, sp`，C代码可以访问：
```c
void trap(struct trapframe *tf) {
    cprintf("异常地址: 0x%x\n", tf->epc);      // 读取sepc
    cprintf("异常原因: %d\n", tf->cause);      // 读取scause
    cprintf("错误地址: 0x%x\n", tf->badvaddr); // 读取stval
}
```

#### Q2: SAVE_ALL中寄存器在栈中的位置是如何确定的？

**答案**：通过 `struct trapframe` 和 `struct pushregs` 的定义保证一致性：

```c
// kern/trap/trap.h
struct pushregs {
    uintptr_t zero;  // 偏移 0*REGBYTES
    uintptr_t ra;    // 偏移 1*REGBYTES
    uintptr_t sp;    // 偏移 2*REGBYTES
    ...
    uintptr_t t6;    // 偏移 31*REGBYTES
};

struct trapframe {
    struct pushregs gpr;  // 占据 0~31*REGBYTES
    uintptr_t status;     // 偏移 32*REGBYTES
    uintptr_t epc;        // 偏移 33*REGBYTES
    uintptr_t badvaddr;   // 偏移 34*REGBYTES
    uintptr_t cause;      // 偏移 35*REGBYTES
};
```

汇编代码严格按此布局写入：
```assembly
STORE x1, 1*REGBYTES(sp)   # 对应 pushregs.ra
STORE s1, 32*REGBYTES(sp)  # 对应 trapframe.status
```

**关键约束**：C结构体的内存布局必须和汇编的STORE/LOAD偏移**完全一致**。

#### Q3: 是否所有中断都需要保存全部寄存器？

**理论分析**：
- **不一定**。根据调用约定，可以只保存"caller-saved"寄存器
- 但在教学OS中，为了**简单和正确**，选择保存所有寄存器

**实际优化可能**：
```c
// 如果中断处理函数遵守调用约定，只需保存:
caller-saved: t0-t6, a0-a7, ra
callee-saved: s0-s11, sp
```

但这要求：
1. 中断处理函数用C编写且编译器遵守约定
2. 不会在中断中切换进程（否则需保存完整上下文）

uCore为了支持未来的进程切换，**保存全部寄存器**是必要的。

### 4.3 实际中断流程追踪（基于运行输出）

结合前面3.6节的实际运行输出，我们可以追踪两个关键的中断/异常处理实例：

#### 实例1：非法指令异常（mret）

**触发时刻**：T5（intr_enable()之后，执行到 `asm volatile("mret")`）

```
[运行输出]
sbi_emulate_csr_read: hartid0: invalid csr_num=0x302
Illegal instruction caught at 0xffffffffc020009c
Exception type: Illegal instruction
```

**完整流程分析**：

```
1️⃣ [用户代码] 0xffffffffc020009c: mret (30200073)
   ↓ mret是M模式指令，在S模式执行→触发异常

2️⃣ [硬件自动] 保存现场
   sepc ← 0xffffffffc020009c        (异常指令地址)
   scause ← 2                        (CAUSE_ILLEGAL_INSTRUCTION)
   stval ← 0x30200073                (非法指令码)
   sstatus.SPIE ← sstatus.SIE (1)
   sstatus.SIE ← 0                   (禁用中断)
   sstatus.SPP ← 1                   (来自S模式)
   PC ← stvec (0xffffffffc0200xxx)   (跳转到__alltraps)

3️⃣ [trapentry.S] __alltraps
   csrw sscratch, sp                 保存旧sp
   addi sp, sp, -36*8                分配288字节trapframe
   STORE x0~x31                      保存32个寄存器
   csrrw s0, sscratch, x0            取回旧sp，清零sscratch
   STORE s0, 2*8(sp)                 保存旧sp到trapframe.gpr.sp
   csrr s1, sstatus                  读取sstatus
   csrr s2, sepc                     读取sepc
   csrr s3, sbadaddr                 读取stval
   csrr s4, scause                   读取scause
   STORE s1~s4, 32*8~35*8(sp)        保存4个CSR到trapframe
   move a0, sp                       a0=trapframe地址
   jal trap                          调用C函数

4️⃣ [trap.c] trap() → trap_dispatch() → exception_handler()
   switch (tf->cause) {              // cause = 2
     case CAUSE_ILLEGAL_INSTRUCTION:
       cprintf("Illegal instruction caught at 0x%llx\n", tf->epc);
       cprintf("Exception type: Illegal instruction\n");
       tf->epc = advance_pc(tf->epc); // 读取0x30200073，最低2位=11→+4
                                      // tf->epc = 0x9c + 4 = 0xa0
       break;
   }
   return;

5️⃣ [trapentry.S] __trapret
   LOAD s1, 32*8(sp)                 s1=sstatus
   LOAD s2, 33*8(sp)                 s2=sepc (已被修改为0xa0)
   csrw sstatus, s1                  恢复sstatus
   csrw sepc, s2                     写入新的sepc
   LOAD x1~x31                       恢复寄存器
   LOAD x2, 2*8(sp)                  恢复sp

6️⃣ [硬件自动] sret指令
   PC ← sepc (0xffffffffc02000a0)    跳转到下一条指令(ebreak)
   特权级 ← sstatus.SPP (S模式)
   sstatus.SIE ← sstatus.SPIE (1)   重新使能中断
   sstatus.SPIE ← 1
   sstatus.SPP ← 0

7️⃣ [继续执行] 0xffffffffc02000a0: ebreak
   ↓ 紧接着触发下一个异常
```

#### 实例2：时钟中断（IRQ_S_TIMER）

**触发时刻**：T8+（进入while(1)后，每10ms一次）

```
[运行输出]
100 ticks    ← 第100次时钟中断
```

**完整流程分析**：

```
1️⃣ [硬件计时器] OpenSBI设置的M模式定时器到期
   ↓ M模式时钟中断委托给S模式
   ↓ CPU在while(1)循环中被打断

2️⃣ [硬件自动] 保存现场
   sepc ← 0xffffffffc02000a2        (while(1)中的j指令地址)
   scause ← 0x8000000000000005      (最高位=1表示中断, 低位=5表示S_TIMER)
   stval ← 0                         (中断不设置stval)
   sstatus.SPIE ← sstatus.SIE (1)
   sstatus.SIE ← 0                   (禁用中断，防止嵌套)
   sstatus.SPP ← 1                   (来自S模式)
   PC ← stvec                        (跳转到__alltraps)

3️⃣ [trapentry.S] SAVE_ALL
   （同实例1，保存完整trapframe）

4️⃣ [trap.c] trap() → interrupt_handler()
   intptr_t cause = (tf->cause << 1) >> 1;  // 抹掉最高位，cause=5
   switch (cause) {
     case IRQ_S_TIMER:                      // 匹配
       clock_set_next_event();              // 设置下一次中断
       ticks++;                             // ticks从0累加
       if (ticks % 100 == 0) {              // 每100次
         print_ticks();                     // 输出"100 ticks"
         tick_prints++;
         if (tick_prints == 10) {
           sbi_shutdown();                  // 第10次关机
         }
       }
       break;
   }

5️⃣ [trapentry.S] RESTORE_ALL + sret
   （恢复所有寄存器，sepc保持0xa2不变）
   PC ← sepc (0xa2)                         返回while(1)循环
   继续执行j指令→下一次循环→等待下次中断
```

#### 关键CSR变化追踪

| 阶段 | sepc | scause | sstatus.SIE | sstatus.SPP | sscratch |
|------|------|--------|-------------|-------------|----------|
| 正常执行mret前 | - | - | 1 (中断开启) | - | 0 (在S模式) |
| mret触发异常 | 0x9c | 2 | 0 (自动禁用) | 1 (来自S) | 0 |
| SAVE_ALL后 | 0x9c | 2 | 0 | 1 | 0 (被清零) |
| exception_handler修改 | **0xa0** | 2 | 0 | 1 | 0 |
| sret返回后 | - | 2 | 1 (恢复) | 0 (清零) | 0 |
| 执行ebreak | 0xa0 | **3** | 0 | 1 | 0 |
| ebreak处理后返回 | - | 3 | 1 | 0 | 0 |
| 时钟中断触发 | 0xa2 | **0x8...5** | 0 | 1 | 0 |
| 时钟中断返回 | - | 0x8...5 | 1 | 0 | 0 |

#### 输出与代码的对应关系

```c
// kern/init/init.c:38-39
    asm volatile("mret");    // ← 输出: Illegal instruction caught at 0xffffffffc020009c
    asm volatile("ebreak");  // ← 输出: ebreak caught at 0xffffffffc02000a0
    while (1);               // ← 在此循环中等待时钟中断

// kern/trap/trap.c:188-191
    cprintf("Illegal instruction caught at 0x%llx\n", tf->epc);
    cprintf("Exception type: Illegal instruction\n");
    // ↑ 对应输出的两行

// kern/trap/trap.c:141-149
    clock_set_next_event();  // ← 设置10ms后的下一次中断
    ticks++;                 // ← 第100次时ticks % 100 == 0
    if (ticks % TICK_NUM == 0) {
        print_ticks();       // ← 输出: 100 ticks
```

---

## 5. Challenge2：上下文切换机制

### 5.1 sscratch寄存器的巧妙用法

#### 问题：如何区分中断来自U模式还是S模式？

RISC-V约定一个技巧：
```
约定:
  - U模式运行时，sscratch = 内核栈地址
  - S模式运行时，sscratch = 0
```

#### 完整的U/S态中断处理方案

```assembly
# 理想的完整版本 (uCore简化版未实现)
__alltraps:
    csrrw sp, sscratch, sp        # 交换sp和sscratch
    bnez sp, from_user            # 如果sp!=0，说明原来sscratch有值→来自U态

from_kernel:
    csrr sp, sscratch             # 来自S态，恢复原sp
    j save_context

from_user:
    # sp已经是内核栈，sscratch保存了用户sp
    j save_context
```

### 5.2 代码中的 `csrw sscratch, sp` 和 `csrrw s0, sscratch, x0`

#### 当前代码（简化版，仅处理S态）：
```assembly
# trapentry.S
SAVE_ALL:
    csrw sscratch, sp              # ①先把旧sp存入sscratch
    addi sp, sp, -36*REGBYTES      # ②调整sp分配trapframe
    ...
    csrrw s0, sscratch, x0         # ③读取sscratch到s0，同时写0到sscratch
    STORE s0, 2*REGBYTES(sp)       # ④把旧sp保存到trapframe
```

**逐步解析**：
1. **第①步**：备份原始栈指针到sscratch（此时sscratch=旧sp）
2. **第②步**：修改sp指向新分配的trapframe空间
3. **第③步**：
   - 读操作：`s0 ← sscratch`（获取旧sp）
   - 写操作：`sscratch ← 0`（标记已进入中断，防止嵌套混乱）
4. **第④步**：把旧sp存入trapframe.gpr.sp字段

**为什么要清零sscratch？**
```
场景：中断处理过程中又发生异常
  → 此时sscratch=0，可以判断"已经在内核态"
  → 避免错误地把内核栈地址再次写入sscratch
```

### 5.3 为什么保存stval/scause但不恢复？

#### 这些CSR的性质

| CSR | 读写属性 | 生命周期 |
|-----|---------|---------|
| **scause** | 硬件写，软件只读 | 每次trap发生时硬件更新 |
| **stval** | 硬件写，软件只读 | 随scause一起更新 |
| **sepc** | 硬件写，软件可写 | 需要恢复（决定返回地址） |
| **sstatus** | 软硬件都可写 | 需要恢复（决定特权级和中断状态） |

#### 保存但不恢复的原因

```c
// 在trap()函数中读取这些信息
void trap(struct trapframe *tf) {
    cprintf("异常原因: %d\n", tf->cause);     // 读取scause
    cprintf("错误地址: 0x%x\n", tf->badvaddr); // 读取stval
    // 这些值仅用于诊断和日志，不需要恢复
}
```

**关键点**：
- **scause/stval** 是**诊断信息**，用于判断如何处理异常
- 当trap返回后，下次trap会重新由硬件写入
- 恢复它们毫无意义（硬件会覆盖）

**必须恢复的CSR**：
- **sepc**: 决定sret后跳转到哪里
- **sstatus**: 决定返回的特权级和中断状态

---

## 6. Challenge3：异常处理完善

### 6.1 实验要求
捕获并处理以下异常：
1. **非法指令异常**（如执行 `mret`）
2. **断点异常**（`ebreak`）

输出格式：
```
Illegal instruction caught at 0x80200058
Exception type: Illegal instruction

ebreak caught at 0x8020005c
Exception type: breakpoint
```

### 6.2 压缩指令与PC调整问题

#### RISC-V指令长度规则
RISC-V支持**混合长度指令**：
- **标准指令**（RV32I/RV64I）：32位（4字节）
- **压缩指令**（RV32C/RV64C）：16位（2字节）

如何判断？看指令最低2位：
```
inst[1:0] == 11 → 32位标准指令 (PC += 4)
inst[1:0] != 11 → 16位压缩指令 (PC += 2)
```

#### advance_pc() 函数实现

```c
// kern/trap/trap.c
static inline uintptr_t advance_pc(uintptr_t epc) {
    uint16_t inst = *(uint16_t *)epc;  // 读取指令的低16位
    return (inst & 0x3) == 0x3 ? epc + 4 : epc + 2;
}
```

**代码解析**：
1. `uint16_t inst = *(uint16_t *)epc`：从异常地址读取2字节
2. `inst & 0x3`：提取最低2位
3. `== 0x3`：判断是否为 `11`（标准指令）
4. 三元运算符：标准指令+4，压缩指令+2

### 6.3 异常处理实现

#### 非法指令处理
```c
// kern/trap/trap.c (181-192行)
case CAUSE_ILLEGAL_INSTRUCTION:
    cprintf("Illegal instruction caught at 0x%llx\n",
            (unsigned long long)tf->epc);
    cprintf("Exception type: Illegal instruction\n");
    tf->epc = advance_pc(tf->epc);  // 跳过非法指令，继续执行
    break;
```

**关键问题**：为什么要修改 `tf->epc`？
```
如果不修改epc:
  → sret返回时PC = 原epc (非法指令地址)
  → 再次执行非法指令
  → 无限循环触发异常

修改epc后:
  → sret返回时PC = epc + 指令长度
  → 跳过非法指令，继续执行后续代码
```

#### 断点异常处理
```c
// kern/trap/trap.c (193-204行)
case CAUSE_BREAKPOINT:
    cprintf("ebreak caught at 0x%llx\n",
            (unsigned long long)tf->epc);
    cprintf("Exception type: breakpoint\n");
    tf->epc = advance_pc(tf->epc);  // 跳过ebreak指令
    break;
```

### 6.4 测试代码

```c
// kern/init/init.c (38-39行)
int kern_init(void) {
    ...
    intr_enable();           // 使能中断

    asm volatile("mret");    // ①触发非法指令异常
    asm volatile("ebreak");  // ②触发断点异常

    while (1);               // ③进入无限循环等待时钟中断
}
```

**执行流程**：
```
1. intr_enable() → sstatus.SIE = 1
2. 执行 mret:
   → M模式特权指令在S模式执行 → 触发CAUSE_ILLEGAL_INSTRUCTION
   → 进入exception_handler
   → 打印信息，epc += 4
   → sret返回，继续执行
3. 执行 ebreak:
   → 触发CAUSE_BREAKPOINT
   → 打印信息，epc += 2 (ebreak通常是压缩指令)
   → sret返回
4. 进入while(1)循环
5. 每10ms触发时钟中断 → 打印"100 ticks"
6. 10次后关机
```

### 6.5 scause编码参考

根据RISC-V特权架构手册：
```c
// libs/riscv.h
#define CAUSE_ILLEGAL_INSTRUCTION  2   // 非法指令
#define CAUSE_BREAKPOINT           3   // 断点异常
#define CAUSE_MISALIGNED_LOAD      4   // 地址未对齐(load)
#define CAUSE_FAULT_LOAD           5   // 访存错误(load)
#define CAUSE_USER_ECALL           8   // U模式ecall
#define CAUSE_SUPERVISOR_ECALL     9   // S模式ecall

#define IRQ_S_TIMER                5   // S模式时钟中断 (scause最高位=1)
```

### 6.6 实际测试与验证

#### 测试方法

**① 快速验证**：
```bash
make qemu
# 观察前几行输出，应该看到:
# Illegal instruction caught at 0xffffffffc020009c
# Exception type: Illegal instruction
# ebreak caught at 0xffffffffc02000a0
# Exception type: breakpoint
```

**② 自动化测试**：
使用提供的测试脚本 [test_challenge3.sh](test_challenge3.sh)：
```bash
chmod +x test_challenge3.sh
./test_challenge3.sh
```

#### 实际运行结果

运行 `make qemu` 后，异常处理部分的输出：

```
++ setup timer interrupts
sbi_emulate_csr_read: hartid0: invalid csr_num=0x302
Illegal instruction caught at 0xffffffffc020009c
Exception type: Illegal instruction
ebreak caught at 0xffffffffc02000a0
Exception type: breakpoint
100 ticks
100 ticks
...
```

#### 输出详细分析

**① OpenSBI警告（可忽略）**：
```
sbi_emulate_csr_read: hartid0: invalid csr_num=0x302
```
- `0x302` 是 `medeleg` 寄存器（M模式异常委托寄存器）
- `mret` 指令尝试访问M模式CSR，OpenSBI给出警告
- 这是预期行为，不影响异常处理的正确性

**② 非法指令异常**：
```
Illegal instruction caught at 0xffffffffc020009c
Exception type: Illegal instruction
```
- ✅ 成功捕获 `mret` 非法指令
- ✅ 异常地址正确（0xffffffffc020009c）
- ✅ 异常类型正确输出

**验证**：通过objdump查看：
```bash
$ riscv64-unknown-elf-objdump -d bin/kernel | grep -A1 "mret"
ffffffffc020009c:  30200073    mret
```
地址完全匹配！

**③ 断点异常**：
```
ebreak caught at 0xffffffffc02000a0
Exception type: breakpoint
```
- ✅ 成功捕获 `ebreak` 断点异常
- ✅ 异常地址正确（0xffffffffc02000a0）
- ✅ 异常类型正确输出

**验证**：
```bash
$ riscv64-unknown-elf-objdump -d bin/kernel | grep "ebreak"
ffffffffc02000a0:  9002        c.ebreak
```
注意：`c.ebreak` 是**压缩指令**（2字节），编码为 `0x9002`

**④ 指令长度处理验证**：

```
地址差 = 0xa0 - 0x9c = 4字节  ← mret是标准指令
下一条 = 0xa0              ← 正确跳转到ebreak

ebreak处理后:
advance_pc(0xa0):
  读取 0x9002
  0x9002 & 0x3 = 0b10 ≠ 0x3
  → 判断为压缩指令
  → 返回 0xa0 + 2 = 0xa2

0xa2 正好是 while(1) 的起始地址！
```

通过汇编验证：
```bash
$ riscv64-unknown-elf-objdump -d bin/kernel | sed -n '/.../p'
ffffffffc020009c:  30200073    mret          # 4字节
ffffffffc02000a0:  9002        c.ebreak      # 2字节
ffffffffc02000a2:  a001        j 0xa2        # while(1)
```

**⑤ 程序流正确性验证**：

```
执行序列:
1. 0x9c: mret        → 异常 → epc修改为0xa0 → 返回
2. 0xa0: ebreak      → 异常 → epc修改为0xa2 → 返回
3. 0xa2: j 0xa2      → 无限循环 → 等待时钟中断
4. 时钟中断触发     → 打印"100 ticks" → 返回0xa2继续循环
```

如果 `advance_pc()` 错误处理：
```
❌ 错误场景:
ebreak异常后 epc = 0xa0 + 4 = 0xa4
→ 0xa4不是合法指令起始
→ 可能触发非对齐异常或执行错误指令
→ 系统崩溃
```

#### 完整性检查

| 检查项 | 期望结果 | 实际结果 | 状态 |
|--------|---------|---------|------|
| 非法指令异常捕获 | "Illegal instruction caught at 0x..." | ✅ 正确输出 | ✅ 通过 |
| 非法指令类型输出 | "Exception type: Illegal instruction" | ✅ 正确输出 | ✅ 通过 |
| 断点异常捕获 | "ebreak caught at 0x..." | ✅ 正确输出 | ✅ 通过 |
| 断点类型输出 | "Exception type: breakpoint" | ✅ 正确输出 | ✅ 通过 |
| 异常地址准确性 | 与objdump一致 | ✅ 0x9c和0xa0正确 | ✅ 通过 |
| 压缩指令处理 | ebreak后PC正确+2 | ✅ 0xa0→0xa2 | ✅ 通过 |
| 程序流连续性 | 异常后继续执行到while(1) | ✅ 进入循环接收时钟中断 | ✅ 通过 |
| 时钟中断正常 | 输出"100 ticks" | ✅ 每秒输出一次 | ✅ 通过 |

#### 可能的异常情况与排查

**如果没有看到异常输出**：
1. 检查 `kern/init/init.c` 是否包含测试代码
   ```c
   asm volatile("mret");
   asm volatile("ebreak");
   ```

2. 检查 `kern/trap/trap.c` 中的异常处理是否实现
   ```c
   case CAUSE_ILLEGAL_INSTRUCTION:
   case CAUSE_BREAKPOINT:
   ```

**如果系统在异常后崩溃**：
- 检查 `advance_pc()` 函数是否正确实现
- 确认 `tf->epc` 被正确修改

**如果看到"sbi_emulate_csr_read"警告**：
- 这是正常现象，OpenSBI的调试信息
- 不影响功能，可以忽略


## 7. 关键代码讲解

### 7.1 中断初始化 (kern/trap/trap.c)

```c
void idt_init(void) {
    extern void __alltraps(void);

    // ①初始化sscratch为0，表示当前在S模式
    write_csr(sscratch, 0);

    // ②设置中断向量表基址为__alltraps入口
    write_csr(stvec, &__alltraps);
}
```

**配合 init.c 的调用顺序**：
```c
int kern_init(void) {
    cons_init();      // 初始化控制台
    idt_init();       // 设置stvec
    clock_init();     // 设置第一次时钟事件
    intr_enable();    // sstatus.SIE = 1，开启中断
    ...
}
```

### 7.2 中断入口 (kern/trap/trapentry.S)

```assembly
.globl __alltraps
.align(2)             # 必须4字节对齐
__alltraps:
    SAVE_ALL          # 保存所有寄存器到栈
    move a0, sp       # trapframe地址 → 第一个参数
    jal trap          # 调用C函数

.globl __trapret
__trapret:
    RESTORE_ALL       # 恢复寄存器
    sret              # 返回
```

**对齐要求**：
```
stvec的MODE字段 (最低2位):
  00 = Direct模式，所有trap跳转到stvec[63:2]对齐的地址
  01 = Vectored模式，中断跳转到stvec+4*cause

uCore使用Direct模式 → stvec必须4字节对齐
```

### 7.3 中断分发 (kern/trap/trap.c)

```c
void trap(struct trapframe *tf) {
    trap_dispatch(tf);
}

static inline void trap_dispatch(struct trapframe *tf) {
    if ((intptr_t)tf->cause < 0) {  // 最高位=1 → 中断
        interrupt_handler(tf);
    } else {                         // 最高位=0 → 异常
        exception_handler(tf);
    }
}
```

**scause最高位判断技巧**：
```c
intptr_t cause = tf->cause;  // 有符号整数
if (cause < 0) {             // 负数 → 最高位=1 → 中断
    ...
}
```

### 7.4 时钟驱动 (kern/driver/clock.c)

```c
static uint64_t timebase = 100000;  // QEMU上约10ms

void clock_set_next_event(void) {
    sbi_set_timer(get_cycles() + timebase);
}

static inline uint64_t get_cycles(void) {
    uint64_t n;
    __asm__ __volatile__("rdtime %0" : "=r"(n));
    return n;
}
```

**SBI调用流程**：
```
clock_set_next_event()
  ↓
sbi_set_timer(stime_value)  // libs/sbi.c
  ↓
sbi_call(SBI_SET_TIMER, ...)  // 触发ecall
  ↓
[硬件] S模式 → M模式
  ↓
OpenSBI固件处理，设置M模式定时器
  ↓
[硬件] mret返回S模式
  ↓
time到达stime_value → 触发IRQ_S_TIMER
```

---

## 8. 知识点总结

### 8.1 实验覆盖的核心知识点

| 知识点 | 理论概念 | 实验实现 |
|--------|---------|---------|
| **中断向量表** | OS通过stvec指向中断入口 | `idt_init()` 设置stvec |
| **上下文切换** | 保存/恢复寄存器状态 | `SAVE_ALL` / `RESTORE_ALL` 宏 |
| **特权级切换** | U/S模式通过trap切换 | trap时SPP保存先前模式 |
| **时钟中断** | 周期性中断驱动调度 | `clock_set_next_event()` 循环设置 |
| **异常处理** | 同步错误需要修正PC | `advance_pc()` 跳过非法指令 |
| **SBI接口** | S模式通过ecall请求M模式服务 | `sbi_set_timer()` / `sbi_shutdown()` |

### 8.2 与OS原理课程的对应关系

#### （1）中断机制
- **原理课**: 讲解中断的概念、分类、处理流程
- **实验**: 实现RISC-V的trap处理，理解硬件/软件分工

#### （2）上下文保存
- **原理课**: 进程上下文、中断上下文的抽象概念
- **实验**: 手写汇编代码，精确控制寄存器布局

#### （3）时钟管理
- **原理课**: 时钟中断驱动进程调度
- **实验**: 实现时钟初始化和计数，为后续调度铺路

#### （4）异常恢复
- **原理课**: 缺页异常、信号处理
- **实验**: 修改epc实现异常指令跳过

### 8.3 原理课重要但实验未涉及的内容

#### （1）多核中断处理
- **原理**: 中断亲和性、IPI（处理器间中断）
- **实验**: 单核QEMU环境，未涉及

#### （2）中断优先级
- **原理**: 嵌套中断、中断屏蔽
- **实验**: 简单禁用所有中断（SIE=0）

#### （3）实时性保证
- **原理**: 中断延迟、中断抖动
- **实验**: 未测量实际时间性能

#### （4）用户态中断处理
- **原理**: 信号机制、upcall
- **实验**: 仅处理内核态中断

---

