# 实验报告（Lab3）

## 实验环境
- 平台：QEMU Virt + OpenSBI v0.4（实验仓库默认环境）
- 交叉工具链：`riscv64-unknown-elf-gcc`（随实验脚本自动调用）
- 主要参考代码目录：`kern/trap/trap.c`、`kern/trap/trapentry.S`、`kern/init/init.c`

## 练习1：完善时钟中断处理
### 关键实现
- 在 `kern/trap/trap.c` 的 `IRQ_S_TIMER` 分支中，调用 `clock_set_next_event()` 安排下一次时钟中断，并递增 `ticks` 计数器。
- 当 `ticks` 达到 `TICK_NUM`（100）倍数时，调用 `print_ticks()` 输出 `"100 ticks"`，并使用文件内静态计数 `tick_prints` 统计打印次数；累计 10 次后，调用 `sbi_shutdown()` 正常关机。
- 通过 `sbi_shutdown()` 触发 OpenSBI 的关机接口，使 QEMU 在 10 次打印后退出，符合实验要求。

### 时钟中断处理流程说明
1. 硬件定时器触发中断，硬件根据 `stvec` 跳转到 `__alltraps`（`trapentry.S`）。
2. `SAVE_ALL` 宏负责保存所有通用寄存器以及 `sstatus`、`sepc`、`stval`、`scause` 等上下文信息，同时通过 `csrw sscratch, sp`、`csrrw` 指令切换栈并留存原栈指针。
3. 汇编入口将保存完毕的栈指针传递给 C 函数 `trap(struct trapframe *tf)`，在 C 语言中根据 `tf->cause` 区分中断/异常，最终调用 `interrupt_handler`。
4. 在 `IRQ_S_TIMER` 分支执行上述逻辑，完成计数与打印，并在需要时关闭机器。
5. `trap()` 返回后，`RESTORE_ALL` 恢复寄存器，`sret` 退回到被中断的指令下一条继续执行。

## Challenge1：描述与理解中断流程
1. **完整流程**：异常/中断发生 → 硬件根据 `stvec` 进入 `__alltraps` → `SAVE_ALL` 保存上下文并切换到内核栈 → 将栈指针传给 C 函数 `trap` → `trap_dispatch` 根据 `scause` 调度到 `interrupt_handler` 或 `exception_handler` → 处理完成后返回 `__trapret` 执行 `RESTORE_ALL` → `sret` 恢复原指令流。
2. **`mov a0, sp` 的目的**：在 `__alltraps` 中，`move a0, sp`（RISC-V 使用 `mv a0, sp`）把当前栈顶地址作为 `trapframe` 指针传递给 C 函数 `trap`，从而让 C 代码能够读取/修改保存的上下文。
3. **`SAVE_ALL` 中寄存器存放位置的确定方式**：`struct pushregs` 明确了保存顺序，`SAVE_ALL` 使用固定偏移把对应寄存器写入栈，这样 C 端可以通过结构体字段名访问正确的寄存器值，保持汇编与 C 的布局一致。
4. **为什么需要保存全部寄存器**：内核 C 代码在处理中断/异常的过程中可能触及任意寄存器；若不保存完整上下译通过，生成 `bin/kernel` 和 `bin/ucore.img`。文，返回后会破坏原执行流。因此在通用实现中选择保存全部寄存器，确保对处理函数的调用是“透明”的（在性能敏感路径下可以按调用约定做针对性优化，但当前教学代码以正确性优先）。

## Challenge2：理解上下文切换机制
1. **`csrw sscratch, sp` 与 `csrrw s0, sscratch, x0` 的作用**：
   - `csrw sscratch, sp` 把进入陷阱前的栈指针写入 `sscratch`。
   - `csrrw s0, sscratch, x0` 同时读取 `sscratch`（得到旧栈指针，保存到 `s0`）并写回 0，确保若在异常处理中再次发生陷阱，可通过 `sscratch == 0` 判断当前已经在内核栈，避免错误覆盖。
2. **为何保存 `stval`、`scause` 但不恢复**：这些 CSR 描述触发陷阱的原因和相关地址，属于一次性的诊断信息。它们在异常处理过程中用于日志和决策，而恢复它们没有意义（硬件会在下次陷阱时重新写入）。因此仅保存供 C 端读取，无需在 `RESTORE_ALL` 中还原。

## Challenge3：完善异常中断
- 在 `exception_handler` 中新增对 `CAUSE_ILLEGAL_INSTRUCTION` 和 `CAUSE_BREAKPOINT` 的专门处理：输出异常类型及触发地址（使用 `%llx`），随后调用辅助函数 `advance_pc` 计算下一条指令地址。
- `advance_pc` 通过读取异常指令的低两位判断是否为压缩指令（16bit），从而决定 PC 前进 2 字节还是 4 字节，避免压缩指令场景下跳转过头。
- 在 `kern/init/init.c` 中加入测试指令 `mret`（会触发非法指令异常）和 `ebreak`（触发断点异常），用于在 QEMU 上验证输出与 PC 前进逻辑。两类异常均能打印指定信息并继续执行至无限循环。

## 知识点总结与原理映射
- **RISC-V 中断向量与 `stvec` 设置**：实验通过 `idt_init` 把 `stvec` 指向统一入口 `__alltraps`，对应原理课中“异常向量表”概念。
- **上下文保存/恢复机制**：`SAVE_ALL`/`RESTORE_ALL` 展示了中断上下文切换的底层细节，与原理课“中断现场保护”内容对应，并体现了 `sscratch` 在判断陷阱来源时的作用。
- **时钟中断驱动系统节拍**：通过 `clock_set_next_event` 和 `ticks` 计数实现软时钟，呼应原理课中的进程调度时钟节拍原理。
- **异常类型区分与 PC 调整**：根据 `scause` 分类处理异常，并通过读取指令长度修正 EPC，映射到原理中“异常返回与指令补偿”的理论。

## 原理课中重要但本实验未覆盖的知识点
- **进程/线程调度实现细节**：本实验只利用时钟中断计数，尚未涉及调度队列与上下文切换到用户进程的完整流程。
- **多核协作下的中断处理**：实验环境使用单核 QEMU，未触及多核中断路由与 IPI 机制。
- **虚拟内存异常的处理策略**：虽然代码框架预留了缺页/权限异常分支，但实验未要求实现页面置换或缺页异常恢复。

## 测试与结果
- `make`：编译通过，生成 `bin/kernel` 和 `bin/ucore.img`。
- `make qemu`：QEMU 启动后依次打印非法指令、断点异常信息，随后每 100 次时钟中断输出一次 `"100 ticks"`，累计 10 行后调用 `sbi_shutdown()` 正常退出，满足实验要求。
